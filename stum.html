<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Guitar String with Orbit Controls</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  #hud { position:absolute; top:10px; left:10px; color:white;
        font-family:sans-serif; background: rgba(0,0,0,0.6);
        padding:8px 12px; border-radius:8px; }
  #hud label { display:block; margin-top:4px; }
</style>
</head>
<body>
<div id="hud">
  <b>Hold S to strum ðŸŽ¸</b>
  <label>Stiffness: <span id="stiffVal">0.05</span>
    <input type="range" id="stiff" min="0.01" max="0.2" step="0.01" value="0.05">
  </label>
  <label>Damping: <span id="dampVal">0.92</span>
    <input type="range" id="damp" min="0.8" max="0.99" step="0.01" value="0.92">
  </label>
  <label>Max Pull: <span id="pullVal">2</span>
    <input type="range" id="pull" min="0.5" max="5" step="0.1" value="2">
  </label>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
<script>
// --- Scene & Camera ---
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
camera.position.set(0,0,10);
let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0x404040));
let dir = new THREE.DirectionalLight(0xffffff,1);
dir.position.set(5,5,5);
scene.add(dir);

// OrbitControls
let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.enableZoom = true;
controls.zoomSpeed = 1.0;
controls.enablePan = true;
controls.panSpeed = 0.8;
controls.screenSpacePanning = false;
controls.minDistance = 3;
controls.maxDistance = 50;
controls.maxPolarAngle = Math.PI/2;

// --- Spheres at string ends ---
let leftSphere = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshPhongMaterial({color:0x44aa88}));
let rightSphere = new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshPhongMaterial({color:0x8844aa}));
leftSphere.position.x=-3; rightSphere.position.x=3;
scene.add(leftSphere,rightSphere);

// --- String setup ---
const SEGMENTS = 60;
let points=[], prevPoints=[], restPositions=[];
let positions=new Float32Array((SEGMENTS+1)*3);
for(let i=0;i<=SEGMENTS;i++){
    let t=i/SEGMENTS;
    let p=new THREE.Vector3(-3+6*t,0,0);
    points.push(p.clone());
    prevPoints.push(p.clone());
    restPositions.push(p.clone());
    positions[i*3]=p.x; positions[i*3+1]=p.y; positions[i*3+2]=p.z;
}
let geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions,3));
let line = new THREE.Line(geometry, new THREE.LineBasicMaterial({color:0xffffff}));
scene.add(line);

// --- Mouse / strum ---
let mouse = new THREE.Vector2(), strumActive=false, draggingVertex=null;
let lastMouse={x:0,y:0};
const maxStep=0.2;

// --- Parameters ---
let stiffness=0.05, damping=0.92, maxPull=2;

// HUD sliders
document.getElementById('stiff').addEventListener('input',e=>{
    stiffness=parseFloat(e.target.value);
    document.getElementById('stiffVal').innerText=stiffness.toFixed(2);
});
document.getElementById('damp').addEventListener('input',e=>{
    damping=parseFloat(e.target.value);
    document.getElementById('dampVal').innerText=damping.toFixed(2);
});
document.getElementById('pull').addEventListener('input',e=>{
    maxPull=parseFloat(e.target.value);
    document.getElementById('pullVal').innerText=maxPull.toFixed(1);
});

// Events
window.addEventListener('keydown',e=>{if(e.key.toLowerCase()==='s') strumActive=true;});
window.addEventListener('keyup',e=>{if(e.key.toLowerCase()==='s'){draggingVertex=null;}});
window.addEventListener('mousemove',e=>{
    mouse.x=(e.clientX/window.innerWidth)*2-1;
    mouse.y=-(e.clientY/window.innerHeight)*2+1;
});

// --- Physics update ---
function updateString(){
    let dx = mouse.x - lastMouse.x;
    let dy = mouse.y - lastMouse.y;
    let speed = Math.sqrt(dx*dx + dy*dy) * 60;
    lastMouse.x = mouse.x; lastMouse.y = mouse.y;

    // grab vertex if mouse close and S held
    let grabVertex = null;
    if(strumActive){
        let minDist = Infinity;
        for(let i=1;i<SEGMENTS;i++){
            let p = points[i].clone().project(camera);
            let dist = Math.sqrt((p.x-mouse.x)**2 + (p.y-mouse.y)**2);
            if(dist<0.05 && dist<minDist){ minDist=dist; grabVertex=i; }
        }
        draggingVertex = grabVertex;
    }

    // apply drag
    if(draggingVertex!==null){
        let ndc = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        ndc.unproject(camera);
        let dy = ndc.y - restPositions[draggingVertex].y;
        let maxDy = Math.min(maxPull, dy * speed * 0.5);
        points[draggingVertex].y = restPositions[draggingVertex].y + maxDy;
        points[draggingVertex].x = restPositions[draggingVertex].x;
    }

    // Verlet + wave propagation
    for(let i=1;i<SEGMENTS;i++){
        if(i===draggingVertex) continue;
        let p=points[i], prev=prevPoints[i];
        let velocity=p.clone().sub(prev).multiplyScalar(damping);
        prevPoints[i].copy(p);

        let leftForce=new THREE.Vector3(), rightForce=new THREE.Vector3();
        if(i>0) leftForce.subVectors(points[i-1],p);
        if(i<SEGMENTS) rightForce.subVectors(points[i+1],p);
        leftForce.multiplyScalar(stiffness); rightForce.multiplyScalar(stiffness);

        let step=velocity.add(leftForce).add(rightForce);
        if(step.length()>maxStep) step.setLength(maxStep);
        p.add(step);
    }

    // Tie ends
    points[0].copy(leftSphere.position);
    points[SEGMENTS].copy(rightSphere.position);

    // Update buffer
    points.forEach((p,i)=>{positions[i*3]=p.x; positions[i*3+1]=p.y; positions[i*3+2]=p.z;});
    geometry.attributes.position.needsUpdate=true;
}

// --- Animate ---
function animate(){
    requestAnimationFrame(animate);
    updateString();
    controls.update();
    renderer.render(scene,camera);
}
animate();

// Resize
window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
