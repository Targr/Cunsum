<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Guitar String with Wave Propagation</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  #hud { position:absolute; top:10px; left:10px; color:white;
        font-family:sans-serif; background: rgba(0,0,0,0.5);
        padding:8px 12px; border-radius:8px; }
</style>
</head>
<body>
<div id="hud">Hold S and drag string ðŸŽ¸</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
// --- Minimal OrbitControls ---
THREE.OrbitControls=function(object,domElement){
    this.object=object; this.domElement=domElement;
    let isDown=false, startX=0,startY=0,rotX=0,rotY=0;
    domElement.addEventListener('mousedown',e=>{if(e.button===0){isDown=true;startX=e.clientX;startY=e.clientY;}});
    domElement.addEventListener('mouseup',e=>{isDown=false;});
    domElement.addEventListener('mousemove',e=>{if(!isDown)return;
        let dx=(e.clientX-startX)*0.005,dy=(e.clientY-startY)*0.005;
        rotY+=dx; rotX+=dy; startX=e.clientX; startY=e.clientY;
        object.rotation.y=rotY; object.rotation.x=rotX;
    });
    this.update=function(){};
};

// --- Scene ---
let scene=new THREE.Scene();
let camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
camera.position.set(0,0,10);
let renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0x404040));
let dir=new THREE.DirectionalLight(0xffffff,1); dir.position.set(5,5,5);
scene.add(dir);

// Controls
let controls=new THREE.OrbitControls(camera,renderer.domElement);

// Spheres
let leftSphere=new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshPhongMaterial({color:0x44aa88}));
let rightSphere=new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshPhongMaterial({color:0x8844aa}));
leftSphere.position.x=-3; rightSphere.position.x=3;
scene.add(leftSphere,rightSphere);

// String
const SEGMENTS=20;  // smoother string
let points=[], prevPoints=[], restPositions=[];
let positions=new Float32Array((SEGMENTS+1)*3);
for(let i=0;i<=SEGMENTS;i++){
    let t=i/SEGMENTS;
    let p=new THREE.Vector3(-3+6*t,0,0);
    points.push(p.clone());
    prevPoints.push(p.clone());
    restPositions.push(p.clone());
    positions[i*3]=p.x; positions[i*3+1]=p.y; positions[i*3+2]=p.z;
}
let geometry=new THREE.BufferGeometry();
geometry.setAttribute('position',new THREE.BufferAttribute(positions,3));
let line=new THREE.Line(geometry,new THREE.LineBasicMaterial({color:0xffffff}));
scene.add(line);

// Mouse
let mouse=new THREE.Vector2(), strumActive=false, draggingVertex=null;
const MAX_PULL=2;

// Events
window.addEventListener('keydown',e=>{if(e.key.toLowerCase()==='s') strumActive=true;});
window.addEventListener('keyup',e=>{if(e.key.toLowerCase()==='s'){draggingVertexRelease();}});
window.addEventListener('mousemove',e=>{
    mouse.x=(e.clientX/window.innerWidth)*2-1;
    mouse.y=-(e.clientY/window.innerHeight)*2+1;
});

function draggingVertexRelease(){ if(draggingVertex!==null){ draggingVertexReleased=true; } draggingVertex=null;}
let draggingVertexReleased=false;

// Wave propagation parameters
const stiffness=0.2, damping=0.96;

// Animate
function updateString(){
    // Grab vertex
    if(strumActive && draggingVertex===null){
        let minDist=Infinity, closest=-1;
        for(let i=1;i<SEGMENTS;i++){
            let p=points[i].clone().project(camera);
            let dx=p.x-mouse.x, dy=p.y-mouse.y;
            let d=Math.sqrt(dx*dx+dy*dy);
            if(d<minDist){ minDist=d; closest=i; }
        }
        if(closest>=0 && minDist<0.05) draggingVertex=closest;
    }

    // Move dragged vertex
    if(draggingVertex!==null && strumActive){
        let ndc=new THREE.Vector3(mouse.x,mouse.y,0.5); ndc.unproject(camera);
        let dy=ndc.y - restPositions[draggingVertex].y;
        if(Math.abs(dy)>MAX_PULL) dy=Math.sign(dy)*MAX_PULL;
        points[draggingVertex].y = restPositions[draggingVertex].y + dy;
        points[draggingVertex].z = ndc.z; // optional z displacement
        points[draggingVertex].x = restPositions[draggingVertex].x; // keep x
    }

    // Verlet-like update with horizontal wave propagation
    for(let i=1;i<SEGMENTS;i++){
        if(i===draggingVertex && strumActive) continue; // frozen
        let p=points[i], prev=prevPoints[i];
        let velocity=p.clone().sub(prev).multiplyScalar(damping);
        prevPoints[i].copy(p);
        // Apply spring force to neighbors
        let leftForce=new THREE.Vector3();
        let rightForce=new THREE.Vector3();
        if(i>0) leftForce.subVectors(points[i-1],p);
        if(i<SEGMENTS) rightForce.subVectors(points[i+1],p);
        leftForce.multiplyScalar(stiffness); rightForce.multiplyScalar(stiffness);
        p.add(velocity).add(leftForce).add(rightForce);
    }

    // Tie ends to spheres
    points[0].copy(leftSphere.position);
    points[SEGMENTS].copy(rightSphere.position);

    // Update buffer
    points.forEach((p,i)=>{positions[i*3]=p.x; positions[i*3+1]=p.y; positions[i*3+2]=p.z;});
    geometry.attributes.position.needsUpdate=true;

    // Reset release flag after first update
    if(draggingVertexReleased) draggingVertexReleased=false;
}

// Animate
function animate(){
    requestAnimationFrame(animate);
    updateString();
    controls.update();
    renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
