<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Guitar String Pull</title>
<style>
  body { margin:0; overflow:hidden; background:black; }
  #hud { position:absolute; top:10px; left:10px; color:white;
        font-family:sans-serif; background: rgba(0,0,0,0.5);
        padding:8px 12px; border-radius:8px; }
</style>
</head>
<body>
<div id="hud">Hold S and drag vertex to pull string ðŸŽ¸</div>
<script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
<script>
// --- Minimal OrbitControls ---
THREE.OrbitControls = function (object, domElement) {
    this.object = object; this.domElement = domElement;
    let isDown=false, startX=0,startY=0,rotX=0,rotY=0;
    domElement.addEventListener('mousedown',e=>{if(e.button===0){isDown=true;startX=e.clientX;startY=e.clientY;}});
    domElement.addEventListener('mouseup',e=>{isDown=false;});
    domElement.addEventListener('mousemove',e=>{if(!isDown)return;
        let dx=(e.clientX-startX)*0.005,dy=(e.clientY-startY)*0.005;
        rotY+=dx; rotX+=dy; startX=e.clientX; startY=e.clientY;
        object.rotation.y=rotY; object.rotation.x=rotX;
    });
    this.update=function(){};
};

// --- Scene ---
let scene=new THREE.Scene();
let camera=new THREE.PerspectiveCamera(60,window.innerWidth/window.innerHeight,0.1,1000);
camera.position.set(0,0,10);
let renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0x404040));
let dir=new THREE.DirectionalLight(0xffffff,1); dir.position.set(5,5,5);
scene.add(dir);

// Controls
let controls=new THREE.OrbitControls(camera,renderer.domElement);

// Spheres
let leftSphere=new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshPhongMaterial({color:0x44aa88}));
let rightSphere=new THREE.Mesh(new THREE.SphereGeometry(0.5,32,32), new THREE.MeshPhongMaterial({color:0x8844aa}));
leftSphere.position.x=-3; rightSphere.position.x=3;
scene.add(leftSphere,rightSphere);

// String
const SEGMENTS=20;
let points=[], velocities=[], restPositions=[];
let positions=new Float32Array((SEGMENTS+1)*3);
for(let i=0;i<=SEGMENTS;i++){
    let t=i/SEGMENTS;
    let p=new THREE.Vector3(-3+6*t,0,0);
    points.push(p.clone());
    restPositions.push(p.clone());
    velocities.push(new THREE.Vector3());
    positions[i*3]=p.x; positions[i*3+1]=p.y; positions[i*3+2]=p.z;
}
let geometry=new THREE.BufferGeometry();
geometry.setAttribute('position',new THREE.BufferAttribute(positions,3));
let line=new THREE.Line(geometry,new THREE.LineBasicMaterial({color:0xffffff}));
scene.add(line);

// Mouse & raycaster
let mouse=new THREE.Vector2(), raycaster=new THREE.Raycaster();
let strumActive=false, draggingVertex=null;

// Events
window.addEventListener('keydown',e=>{if(e.key.toLowerCase()==='s') strumActive=true;});
window.addEventListener('keyup',e=>{if(e.key.toLowerCase()==='s'){strumActive=false; draggingVertex=null;}});
window.addEventListener('mousemove',e=>{
    mouse.x=(e.clientX/window.innerWidth)*2-1;
    mouse.y=-(e.clientY/window.innerHeight)*2+1;

    if(strumActive && draggingVertex===null){
        // pick closest vertex to mouse
        let minDist=Infinity, closest=-1;
        for(let i=1;i<SEGMENTS;i++){
            let p=points[i].clone().project(camera);
            let dx=p.x-mouse.x, dy=p.y-mouse.y;
            let d=Math.sqrt(dx*dx+dy*dy);
            if(d<minDist){ minDist=d; closest=i; }
        }
        if(closest>=0 && minDist<0.05) draggingVertex=closest;
    }
});

// Update physics
function updateString(){
    // pull the dragged vertex
    if(draggingVertex!==null){
        let ndc=new THREE.Vector3(mouse.x,mouse.y,0.5);
        ndc.unproject(camera);
        points[draggingVertex].y = ndc.y;
    }

    for(let i=1;i<SEGMENTS;i++){
        if(i===draggingVertex) continue; // skip pulled vertex
        let dy=restPositions[i].y - points[i].y;
        velocities[i].y += dy*0.1; // spring force
        velocities[i].y *= 0.95;   // damping
        points[i].y += velocities[i].y;
    }

    // tie ends to spheres
    points[0].copy(leftSphere.position);
    points[SEGMENTS].copy(rightSphere.position);

    // optionally snap dragged vertex back if released
    if(!strumActive && draggingVertex!==null){
        draggingVertex=null;
    }

    points.forEach((p,i)=>{positions[i*3]=p.x; positions[i*3+1]=p.y; positions[i*3+2]=p.z;});
    geometry.attributes.position.needsUpdate=true;
}

// Animate
function animate(){
    requestAnimationFrame(animate);
    updateString();
    controls.update();
    renderer.render(scene,camera);
}
animate();

window.addEventListener('resize', ()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
});
</script>
</body>
</html>
