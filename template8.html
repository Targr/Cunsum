<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Wikipedia Graph — Verlet (simple) + Read Summary (TTS) + Auto-Adjacent + Link Glow</title>
<style>
  body { margin:0; overflow:hidden; background:#000; }
  #hud { position:absolute; top:8px; right:8px; color:white; font-family:sans-serif; font-size:13px;
        background:rgba(0,0,0,0.8); padding:12px; border-radius:10px; z-index:30; width:420px; }
  #portal-display { position:absolute; top:8px; left:8px; color:white; font-family:sans-serif; font-size:14px; z-index:30; max-width:560px; white-space:pre-wrap; }
  .btn { padding:6px 8px; margin-right:6px; }
  .small { font-size:12px; color:#ddd; }
  #hud .row { margin-top:8px; }
  #hud .muted { color:#999; font-size:12px; }
</style>
</head>
<body>
<div id="3d-graph" style="width:100%;height:100%;"></div>
<div id="portal-display"></div>

<div id="hud">
  <div><b>Wikipedia Graph Generator</b></div>

  <div class="row">
    <label class="small">Seed articles (comma-separated):<br>
      <input id="seedInput" type="text" style="width:380px;" placeholder="Dog,Cat">
    </label>
  </div>

  <div class="row">
    <label class="small">Direct-neighbor limit:<br>
      <input id="limitInput" type="number" style="width:100px;" placeholder="20">
    </label>
    <label class="small" style="margin-left:10px;">Connector limit:<br>
      <input id="connectorInput" type="number" value="20" style="width:90px;">
    </label>
  </div>

  <div class="row">
    <label><input id="verletToggle" type="checkbox"> Enable Verlet (simple tubes)</label>
    <div class="muted">(Colors halves by node when enabled; no strumming mechanics)</div>
  </div>

  <div class="row">
    <button id="regenBtn" class="btn">Regenerate</button>
    <button id="resetSelect" class="btn">Clear Selection</button>
    <button id="hud-merge-nodes-btn" class="btn">Merge Nodes</button>
    <button id="hud-read-summary-btn" class="btn">Read Summary (TTS)</button>
    <label style="margin-left:8px;">
      <input id="readAdjacent" type="checkbox"> <span class="small">Auto-read adjacent</span>
    </label>
  </div>

  <div class="row">
    <label class="small">Color picker for selected:</label><br>
    <input id="colorInput" type="color" value="#ff0000" style="width:90px;">
    <button id="applyColor" class="btn">Apply Color</button>
  </div>

  <div id="hud-status" class="row" style="margin-top:10px;color:#04B819;"></div>
</div>

<!-- libs -->
<script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
<script src="https://unpkg.com/3d-force-graph"></script>
<script src="https://unpkg.com/three-spritetext"></script>

<script>
/* Quick global error to surface problems */
window.onerror = (msg, src, ln, col, err) => {
  console.error("GLOBAL ERROR:", msg, src, ln, col, err);
  const hud = document.getElementById('hud-status');
  if(hud) hud.innerText = 'JS ERROR — see console';
  return false;
};
</script>

<!-- Accept server-injected __DATA__ for compatibility -->
<script>
try { window.rawData = __DATA__; } catch(e) { window.rawData = { nodes: [], links: [] }; }
let rawData = window.rawData;
</script>

<script>
/* =============================================================================
  Updated template_fixed3.html
  - simpler Verlet (draw tubes between nodes, color halves when enabled)
  - TTS speakNode with glow and auto-adjacent traversal
  - connection description (direction, mutual, shared neighbors)
  - link glow while speaking connection description
  ============================================================================= */

/* ------------------- ForceGraph init ------------------- */
const Graph = ForceGraph3D()(document.getElementById('3d-graph'))
  .graphData(rawData)
  .nodeRelSize(4)
  .nodeLabel(n => {
    if(n.mergedArticles) {
      return `<b>${n.mergedArticles.join(' + ')}</b>\n${(n.mergedSummaries||[]).join('\n\n')}`;
    }
    return `<b>${n.name}</b>\n${n.summary || ''}`;
  })
  .nodeThreeObject(node => {
    // merged nodes: half-and-half shader; otherwise regular sphere mesh
    if(node.mergedColors && Array.isArray(node.mergedColors) && node.mergedColors.length >= 2) {
      const colorA = new THREE.Color(node.mergedColors[0] || '#ff0000');
      const colorB = new THREE.Color(node.mergedColors[1] || '#0000ff');
      const geo = new THREE.SphereGeometry(Math.max(0.8,(node.val||12)/8), 24, 24);
      const mat = new THREE.ShaderMaterial({
        uniforms: { colorA: { value: colorA }, colorB: { value: colorB } },
        vertexShader: `varying vec3 vPos; void main(){ vPos = (modelMatrix * vec4(position,1.0)).xyz; gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0); }`,
        fragmentShader: `uniform vec3 colorA; uniform vec3 colorB; varying vec3 vPos; void main(){ if(vPos.x<0.0) gl_FragColor = vec4(colorA,1.0); else gl_FragColor = vec4(colorB,1.0); }`
      });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData._nodeId = node.id;
      return mesh;
    } else {
      const geo = new THREE.SphereGeometry(Math.max(0.8, (node.val||12)/8), 16, 16);
      const mat = new THREE.MeshStandardMaterial({ color: node.color || '#FFFFFF', emissive: new THREE.Color(0x000000), emissiveIntensity: 0 });
      const mesh = new THREE.Mesh(geo, mat);
      mesh.userData._nodeId = node.id;
      return mesh;
    }
  })
  .linkOpacity(0.6)
  .backgroundColor('#000');

Graph.cameraPosition({ z: Math.max(200, Math.min(2000, (rawData.nodes||[]).length*4)) });

/* ------------------- Simple Verlet-like tubes (no strumming) ------------------- */

/* We'll keep tube geometry updated every engine tick by sampling node positions.
   There is no complex Verlet integration — tubes are evenly interpolated between
   the two node positions. When 'verletToggle' is checked, each half gets the color
   of its corresponding node. When unchecked, tubes are neutral white.
*/

const stringGroup = new THREE.Group();
Graph.scene().add(stringGroup);

const SPRING_SEGMENTS = 18;
let verletEnabled = false;

const linkStates = new Map(); // keys are string "source__target" -> state

function keyForLink(src, tgt) { return `${src}__${tgt}`; }

function makeInitialPoints() {
  const pts = [];
  for(let i=0;i<SPRING_SEGMENTS;i++) pts.push(new THREE.Vector3(0,0,0));
  return pts;
}

function makeLinkState(srcPos, tgtPos) {
  return {
    points: makeInitialPoints(),
    meshA: null,
    meshB: null,
    restLen: 1,
    colorA: '#ffffff',
    colorB: '#ffffff',
    _orig: {}
  };
}

function rebuildTubeGeometry(state) {
  // dispose previous
  if(state.meshA) { stringGroup.remove(state.meshA); disposeMesh(state.meshA); state.meshA = null; }
  if(state.meshB) { stringGroup.remove(state.meshB); disposeMesh(state.meshB); state.meshB = null; }

  const half = Math.floor(SPRING_SEGMENTS/2);
  const ptsA = state.points.slice(0, half+1);
  const ptsB = state.points.slice(half, state.points.length);

  if(ptsA.length >= 2) {
    const curveA = new THREE.CatmullRomCurve3(ptsA, false, 'catmullrom', 0.5);
    const geoA = new THREE.TubeGeometry(curveA, Math.max(2, SPRING_SEGMENTS), 0.12, 8, false);
    const matA = new THREE.MeshStandardMaterial({ color: state.colorA || '#ffffff' });
    state.meshA = new THREE.Mesh(geoA, matA);
    stringGroup.add(state.meshA);
  }
  if(ptsB.length >= 2) {
    const curveB = new THREE.CatmullRomCurve3(ptsB, false, 'catmullrom', 0.5);
    const geoB = new THREE.TubeGeometry(curveB, Math.max(2, SPRING_SEGMENTS), 0.12, 8, false);
    const matB = new THREE.MeshStandardMaterial({ color: state.colorB || '#ffffff' });
    state.meshB = new THREE.Mesh(geoB, matB);
    stringGroup.add(state.meshB);
  }
}

function disposeMesh(m) {
  try {
    if(m.geometry) m.geometry.dispose();
    if(m.material) {
      if(Array.isArray(m.material)) m.material.forEach(x=>x.dispose());
      else m.material.dispose();
    }
  } catch(e) { console.warn('disposeMesh', e); }
}

function initLinkStatesFromRaw() {
  // Clear
  linkStates.forEach((st, k) => {
    if(st.meshA) disposeMesh(st.meshA);
    if(st.meshB) disposeMesh(st.meshB);
  });
  linkStates.clear();
  while(stringGroup.children.length) {
    const c = stringGroup.children[0]; stringGroup.remove(c); try { disposeMesh(c); } catch(e) {}
  }

  (rawData.links || []).forEach(l => {
    const src = l.source, tgt = l.target;
    const k = keyForLink(src, tgt);
    const st = makeLinkState();
    st.colorA = (!verletEnabled) ? '#ffffff' : ( (getNodeColor(src)) || '#88aaff');
    st.colorB = (!verletEnabled) ? '#ffffff' : ( (getNodeColor(tgt)) || '#88aaff');
    linkStates.set(k, st);
    // initial build (will be updated on engine tick)
    rebuildTubeGeometry(st);
  });
}

function getNodeById(id) { return (rawData.nodes || []).find(n=>n.id === id); }
function getNodeColor(id) { const n = getNodeById(id); return n ? (n.color || '#ffffff') : null; }

// Every engine tick, update tubes to reflect current positions
Graph.onEngineTick(() => {
  linkStates.forEach((st, k) => {
    const [src, tgt] = k.split('__');
    const s = getNodeById(src), t = getNodeById(tgt);
    if(!s || !t) return;
    const sv = new THREE.Vector3(s.x||0,s.y||0,s.z||0);
    const tv = new THREE.Vector3(t.x||0,t.y||0,t.z||0);
    // Simply interpolate evenly
    for(let i=0;i<SPRING_SEGMENTS;i++) {
      const u = i/(SPRING_SEGMENTS-1);
      st.points[i].lerpVectors(sv, tv, u);
    }
    // When verlet enabled, make halves adopt node colors; when off, set white
    if(verletEnabled) {
      st.colorA = s.color || st.colorA;
      st.colorB = t.color || st.colorB;
    } else {
      st.colorA = '#ffffff';
      st.colorB = '#ffffff';
    }
    // rebuild geometry (inefficient but simple)
    rebuildTubeGeometry(st);
  });
});

/* Toggle for simplified Verlet: just controls coloring behavior and tube halves.
   No complex physics. */
document.getElementById('verletToggle').addEventListener('change', e => {
  verletEnabled = !!e.target.checked;
  // On toggle, update colors for existing link states
  linkStates.forEach((st, k) => {
    const [src, tgt] = k.split('__');
    if(verletEnabled) {
      st.colorA = getNodeColor(src) || st.colorA;
      st.colorB = getNodeColor(tgt) || st.colorB;
    } else {
      st.colorA = '#ffffff'; st.colorB = '#ffffff';
    }
    rebuildTubeGeometry(st);
  });
});

/* ------------------- Node glow utilities ------------------- */
const originalMaterialState = new Map();
function setGlow(nodeId, on) {
  Graph.scene().traverse(obj => {
    if(obj.isMesh && obj.userData && obj.userData._nodeId === nodeId) {
      try {
        const mat = obj.material;
        if(on) {
          if(!originalMaterialState.has(nodeId)) {
            if(mat instanceof THREE.ShaderMaterial) {
              const ca = (mat.uniforms && mat.uniforms.colorA) ? mat.uniforms.colorA.value.clone() : new THREE.Color(0xff0000);
              const cb = (mat.uniforms && mat.uniforms.colorB) ? mat.uniforms.colorB.value.clone() : new THREE.Color(0x0000ff);
              originalMaterialState.set(nodeId, { type:'shader', colorA: ca, colorB: cb, scale: obj.scale.clone() });
              if(mat.uniforms && mat.uniforms.colorA) mat.uniforms.colorA.value = new THREE.Color(0xffff66);
              if(mat.uniforms && mat.uniforms.colorB) mat.uniforms.colorB.value = new THREE.Color(0xffff66);
            } else {
              const col = mat.color ? mat.color.clone() : new THREE.Color(0xffffff);
              const emiss = mat.emissive ? mat.emissive.clone() : new THREE.Color(0x000000);
              originalMaterialState.set(nodeId, { type:'standard', color: col, emissive: emiss, scale: obj.scale.clone() });
              if(mat.color) mat.color.set(0xffff66);
              if(mat.emissive) { mat.emissive.set(0xffff00); mat.emissiveIntensity = 0.9; }
            }
            obj.scale.set(obj.scale.x*1.4, obj.scale.y*1.4, obj.scale.z*1.4);
          }
        } else {
          const s = originalMaterialState.get(nodeId);
          if(s) {
            if(s.type === 'shader') {
              if(mat.uniforms && mat.uniforms.colorA) mat.uniforms.colorA.value = s.colorA;
              if(mat.uniforms && mat.uniforms.colorB) mat.uniforms.colorB.value = s.colorB;
            } else {
              if(mat.color && s.color) mat.color.copy(s.color);
              if(mat.emissive && s.emissive) { mat.emissive.copy(s.emissive); mat.emissiveIntensity = 0; }
            }
            if(s.scale) obj.scale.copy(s.scale);
            originalMaterialState.delete(nodeId);
          }
        }
      } catch(e) { console.warn('setGlow error', e); }
    }
  });
}

/* ------------------- Link highlight (temporary) ------------------- */
function highlightLink(src, tgt, on) {
  const k1 = keyForLink(src, tgt), k2 = keyForLink(tgt, src);
  [k1, k2].forEach(k => {
    const st = linkStates.get(k);
    if(!st) return;
    if(on) {
      if(st._origColorA === undefined) st._origColorA = st.colorA;
      if(st._origColorB === undefined) st._origColorB = st.colorB;
      st.colorA = st.colorB = '#ffff66';
    } else {
      if(st._origColorA !== undefined) st.colorA = st._origColorA;
      if(st._origColorB !== undefined) st.colorB = st._origColorB;
      delete st._origColorA; delete st._origColorB;
    }
    rebuildTubeGeometry(st);
  });
}

/* ------------------- Speech (TTS) helpers ------------------- */
function speakText(text, opts={rate:1.0,pitch:1.0}) {
  return new Promise(resolve => {
    if(!('speechSynthesis' in window)) {
      alert(text);
      resolve();
      return;
    }
    const utt = new SpeechSynthesisUtterance(text);
    utt.rate = opts.rate || 1.0;
    utt.pitch = opts.pitch || 1.0;
    utt.onend = () => resolve();
    utt.onerror = () => resolve();
    window.speechSynthesis.speak(utt);
  });
}

/* ------------------- Connection description helper ------------------- */
/* For nodes A and B, describe connection:
   - if A->B exists: "A links to B."
   - if B->A exists: "B links to A."
   - if both: "Mutually linked."
   - also check for shared neighbors and mention up to two shared titles.
*/
function connectionDescription(aId, bId) {
  const links = rawData.links || [];
  const aToB = links.some(l => l.source === aId && l.target === bId);
  const bToA = links.some(l => l.source === bId && l.target === aId);

  let desc = '';
  if(aToB && bToA) desc = `${getNodeTitle(aId)} and ${getNodeTitle(bId)} link to each other (mutual links).`;
  else if(aToB) desc = `${getNodeTitle(aId)} links to ${getNodeTitle(bId)}.`;
  else if(bToA) desc = `${getNodeTitle(bId)} links to ${getNodeTitle(aId)}.`;
  else desc = `${getNodeTitle(aId)} and ${getNodeTitle(bId)} are connected (undirected).`;

  // compute neighbors set for each (outgoing & incoming)
  const neighborOf = id => {
    const s = new Set();
    (rawData.links || []).forEach(l => {
      if(l.source === id) s.add(l.target);
      if(l.target === id) s.add(l.source);
    });
    return s;
  };
  const na = neighborOf(aId), nb = neighborOf(bId);
  const common = Array.from(na).filter(x => nb.has(x)).slice(0,2);
  if(common.length > 0) {
    const names = common.map(c => getNodeTitle(c)).join(' and ');
    desc += ` They share link(s) with ${names}.`;
  }
  return desc;
}

function getNodeTitle(id) {
  const n = (rawData.nodes||[]).find(x=>x.id===id);
  return n ? n.name : id;
}

/* ------------------- speakNode + auto-adjacent traversal ------------------- */
async function speakNode(node, visited = new Set()) {
  if(!node || visited.has(node.id)) return;
  visited.add(node.id);

  // display summary and glow node
  document.getElementById('portal-display').innerText = `${node.name}\n\n${node.summary || ''}`;
  setGlow(node.id, true);

  // speak title + summary
  await speakText(`${node.name}. ${node.summary || 'No summary available.'}`);

  // remove glow
  setGlow(node.id, false);

  // if auto-adjacent not requested, stop
  if(!document.getElementById('readAdjacent').checked) return;

  // find neighbors connected to node (either direction)
  const neighborIds = new Set();
  (rawData.links || []).forEach(l => {
    if(l.source === node.id && l.target) neighborIds.add(l.target);
    if(l.target === node.id && l.source) neighborIds.add(l.source);
  });

  const neighbors = Array.from(neighborIds)
    .map(id => rawData.nodes.find(n => n.id === id))
    .filter(n => n && !visited.has(n.id));

  if(neighbors.length === 0) return;

  // pick random neighbor
  const next = neighbors[Math.floor(Math.random() * neighbors.length)];

  // prepare connection description
  const connDesc = connectionDescription(node.id, next.id);

  // highlight link(s) between node and next while speaking the description
  highlightLink(node.id, next.id, true);
  await speakText(connDesc);
  highlightLink(node.id, next.id, false);

  // now recursively speak neighbor
  await speakNode(next, visited);
}

/* HUD binding: start reading selected node */
document.getElementById('hud-read-summary-btn').addEventListener('click', async () => {
  const sel = Array.from(selectedNodes);
  if(sel.length === 0) { alert('No node selected.'); return; }
  const id = sel[0];
  const node = (rawData.nodes || []).find(n => n.id === id);
  if(!node) { alert('Selected node not found.'); return; }
  // cancel any existing speech
  if(window.speechSynthesis) window.speechSynthesis.cancel();
  await speakNode(node, new Set());
});

/* ------------------- Selection, coloring, merge, audio (unchanged features) ------------------- */

let selectedNodes = new Set();

Graph.onNodeClick((node, event) => {
  // m+click triggers audio sequence play
  if(event && event && (event.shiftKey === false) && event && event.button === 0 && event && (event.ctrlKey || event.altKey || event.metaKey) ) {
    // ignore complex combos; main audio is m-key based as before
  }
  // m key behavior (hold 'm' and click) handled via global mKeyDown check below
  if(window.mKeyDown) {
    playNodeSequence(node);
    return;
  }
  const shift = event && event.shiftKey;
  if(shift) {
    if(selectedNodes.has(node.id)) selectedNodes.delete(node.id);
    else selectedNodes.add(node.id);
  } else {
    selectedNodes.clear();
    selectedNodes.add(node.id);
  }
  Graph.scene().traverse(obj => {
    if(obj.isMesh && obj.userData && obj.userData._nodeId) {
      const id = obj.userData._nodeId;
      obj.scale.set(1,1,1);
      if(selectedNodes.has(id)) obj.scale.set(1.4,1.4,1.4);
    }
  });
  document.getElementById('hud-status').innerText = `Selected ${selectedNodes.size} node(s).`;
});

/* Apply color to selected nodes */
document.getElementById('applyColor').addEventListener('click', () => {
  const color = document.getElementById('colorInput').value;
  selectedNodes.forEach(nid => {
    const n = rawData.nodes.find(x => x.id === nid);
    if(n) n.color = color;
    // update mesh material color
    Graph.scene().traverse(obj => {
      if(obj.isMesh && obj.userData && obj.userData._nodeId === nid) {
        if(obj.material && obj.material.color) obj.material.color.set(color);
      }
    });
  });
  // update link halves too
  linkStates.forEach((st, k) => {
    const [src,tgt] = k.split('__');
    st.colorA = getNodeColor(src) || st.colorA;
    st.colorB = getNodeColor(tgt) || st.colorB;
    rebuildTubeGeometry(st);
  });
});

/* Clear selection */
document.getElementById('resetSelect').addEventListener('click', () => {
  selectedNodes.clear();
  Graph.scene().traverse(obj => { if(obj.isMesh && obj.userData && obj.userData._nodeId) obj.scale.set(1,1,1); });
  document.getElementById('hud-status').innerText = 'Selection cleared.';
});

/* Merge HUD button (keeps earlier behavior) */
document.getElementById('hud-merge-nodes-btn').addEventListener('click', () => {
  const sel = Array.from(selectedNodes);
  if(sel.length < 2) { alert('Select at least 2 nodes to merge (Shift+Click).'); return; }
  const idsToMerge = sel.slice(0,2);
  const toMerge = idsToMerge.map(id => rawData.nodes.find(n=>n.id===id)).filter(Boolean);
  if(toMerge.length < 2) { alert('Nodes incomplete'); return; }
  const mergedId = idsToMerge.join('||');
  let avgX=0,avgY=0,avgZ=0;
  toMerge.forEach(n => { avgX += (n.x||0); avgY += (n.y||0); avgZ += (n.z||0); });
  avgX/=toMerge.length; avgY/=toMerge.length; avgZ/=toMerge.length;
  const mergedNode = { id:mergedId, name:mergedId, val: Math.max(...toMerge.map(n=>n.val||12)), mergedArticles:[], mergedSummaries:[], mergedPortals:[], mergedColors: toMerge.slice(0,2).map(n=>n.color||'#ff0000'), color: toMerge[0].color||'#ffffff', x:avgX, y:avgY, z:avgZ };
  toMerge.forEach(n => {
    mergedNode.mergedArticles.push(...(n.mergedArticles||[n.name||n.id]));
    mergedNode.mergedSummaries.push(...(n.mergedSummaries||[n.summary||'']));
  });
  const mergeSet = new Set(idsToMerge);
  const rewired = [];
  (rawData.links||[]).forEach(l => {
    const src = (typeof l.source === 'object') ? l.source.id : l.source;
    const tgt = (typeof l.target === 'object') ? l.target.id : l.target;
    const newSrc = mergeSet.has(src) ? mergedId : src;
    const newTgt = mergeSet.has(tgt) ? mergedId : tgt;
    if(newSrc === newTgt) return;
    rewired.push({ source: newSrc, target: newTgt, color: l.color || '#cccccc' });
  });
  const seen = new Set(); const dedup = [];
  rewired.forEach(l => {
    const k = `${l.source}>>${l.target}`;
    if(seen.has(k)) return; seen.add(k); dedup.push(l);
  });
  rawData.nodes = (rawData.nodes||[]).filter(n => !mergeSet.has(n.id));
  rawData.nodes.push(mergedNode);
  rawData.links = dedup;
  Graph.graphData(rawData);
  initLinkStatesFromRaw();
  Graph.refresh();
  selectedNodes.clear();
  document.getElementById('hud-status').innerText = `Merged ${idsToMerge.join(', ')} → ${mergedId}`;
});

/* ------------------- Audio m+click melodic traversal (unchanged concept) ------------------- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let selectedScale = [0,2,3,5,7,9,11];
let selectedOctave = 4;
let selectedInstrument = 'sine';
window.mKeyDown = false;
document.addEventListener('keydown', e => { if(e.key && e.key.toLowerCase()==='m') window.mKeyDown = true; });
document.addEventListener('keyup', e => { if(e.key && e.key.toLowerCase()==='m') window.mKeyDown = false; });

function letterToNote(char) {
  const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  const idx = alphabet.indexOf(char.toUpperCase());
  if(idx === -1) return null;
  return 12*selectedOctave + selectedScale[idx % selectedScale.length];
}
function playMidi(midi,duration=300,volume=0.3) {
  if(midi == null) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = selectedInstrument;
  o.frequency.value = 440 * Math.pow(2, (midi-69)/12);
  g.gain.value = volume; o.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + duration/1000);
}
async function playWord(w, d = 180) {
  for(const ch of w) {
    playMidi(letterToNote(ch), d, 0.35);
    await new Promise(r => setTimeout(r, d));
  }
}
async function playNodeSequence(node, visited = new Set()) {
  if(!node || visited.has(node.id)) return;
  visited.add(node.id);
  document.getElementById('portal-display').innerText = node.mergedSummaries ? node.mergedSummaries.join('\n\n') : (node.summary || '');
  const orig = node.color;
  node.color = '#FF00FF';
  Graph.refresh();
  (rawData.links||[]).forEach(l => { if(l.source===node.id||l.target===node.id) { l.color='#FF00FF'; l.opacity=1; }});
  Graph.refresh();
  await playWord(node.name || (node.mergedArticles ? node.mergedArticles[0] : ''), 160);
  node.color = orig;
  (rawData.links||[]).forEach(l => { if(l.source===node.id||l.target===node.id) { l.color='#cccccc'; l.opacity=0.6; }});
  Graph.refresh();
  const connected = (rawData.links||[]).filter(l => l.source === node.id).map(l => (rawData.nodes||[]).find(n => n.id === l.target));
  for(const n of connected) await playNodeSequence(n, visited);
}

/* ------------------- Regeneration (client-side, filters Talk: pages) ------------------- */
function isTalkPage(title) { if(!title) return false; return /^talk:/i.test(title); }

async function fetchBacklinks(title, max) {
  const out = [];
  let blcontinue = null;
  while(out.length < max) {
    const params = new URLSearchParams({ action:'query', list:'backlinks', bltitle:title, bllimit:'max', format:'json' });
    if(blcontinue) params.set('blcontinue', blcontinue);
    const res = await fetch('https://en.wikipedia.org/w/api.php?origin=*' + '&' + params.toString());
    const j = await res.json();
    const bls = j.query?.backlinks?.map(x => x.title) || [];
    out.push(...bls);
    if(!j.continue?.blcontinue) break;
    blcontinue = j.continue.blcontinue;
  }
  return out.slice(0, max);
}

async function fetchSummary(title) {
  try {
    const res = await fetch('https://en.wikipedia.org/api/rest_v1/page/summary/' + encodeURIComponent(title));
    if(!res.ok) return 'No summary available';
    const j = await res.json();
    return j.extract || 'No summary available';
  } catch(e) { console.warn('Summary fetch fail', e); return 'No summary available'; }
}

document.getElementById('regenBtn').addEventListener('click', async () => {
  const seedText = document.getElementById('seedInput').value.trim();
  const seeds = seedText ? seedText.split(',').map(s=>s.trim()).filter(Boolean) : [];
  const limitVal = parseInt(document.getElementById('limitInput').value);
  const connectorLimit = parseInt(document.getElementById('connectorInput').value) || 20;
  const limit = isNaN(limitVal) ? null : limitVal;
  document.getElementById('hud-status').innerText = 'Fetching graph...';
  try {
    let visited = new Set(), resultArticles = [];

    // include seeds (skip Talk:)
    for(const s of seeds) if(!isTalkPage(s) && !visited.has(s)) { resultArticles.push(s); visited.add(s); }

    // collect direct neighbors (round-robin)
    let directNeighbors = [];
    if(limit !== null) {
      const backlinkQueues = [];
      for(const s of seeds) {
        if(isTalkPage(s)) { backlinkQueues.push({seed:s, backlinks:[]}); continue; }
        const bls = await fetchBacklinks(s, limit || 200);
        backlinkQueues.push({seed:s, backlinks: bls.filter(b => !isTalkPage(b))});
      }
      let i=0;
      while(directNeighbors.length < (limit||0) && backlinkQueues.some(q => q.backlinks.length > 0)) {
        const q = backlinkQueues[i % backlinkQueues.length];
        if(q.backlinks.length > 0) {
          const b = q.backlinks.shift();
          if(!visited.has(b) && !directNeighbors.includes(b)) directNeighbors.push(b);
        }
        i++;
      }
    } else {
      for(const s of seeds) {
        if(isTalkPage(s)) continue;
        const bls = await fetchBacklinks(s, 200);
        for(const b of bls) {
          if(isTalkPage(b)) continue;
          if(!visited.has(b) && !directNeighbors.includes(b)) directNeighbors.push(b);
        }
      }
    }

    // append direct neighbors
    for(const dn of directNeighbors) if(!visited.has(dn)) { resultArticles.push(dn); visited.add(dn); }

    // per-direct-neighbor offshoots
    for(const dn of directNeighbors) {
      const bls = await fetchBacklinks(dn, connectorLimit);
      for(const b of bls) {
        if(isTalkPage(b)) continue;
        if(!visited.has(b)) { resultArticles.push(b); visited.add(b); }
      }
    }

    // Build links among resultArticles
    const articleSet = new Set(resultArticles.filter(a => !isTalkPage(a)));
    const links = [];
    for(const a of resultArticles) {
      if(isTalkPage(a)) continue;
      const bls = await fetchBacklinks(a, 200);
      for(const b of bls) {
        if(isTalkPage(b)) continue;
        if(articleSet.has(b)) links.push({ source: b, target: a, color:'#cccccc' });
      }
    }

    // Build nodes with summaries
    const nodes = [];
    for(const a of Array.from(articleSet)) {
      const summary = await fetchSummary(a);
      nodes.push({ id: a, name:a, color:'#ffffff', val:12, summary });
    }

    // seed color map
    const seedColors = ["#ff0000","#00ff00","#0000ff","#ff00ff","#00ffff","#ffff00","#ff8800","#8800ff","#0088ff","#88ff00","#ff0088","#00ff88"];
    const seedColorMap = {};
    seeds.forEach((s,i) => { if(!isTalkPage(s)) seedColorMap[s] = seedColors[i % seedColors.length]; });

    // mark seeds
    for(const s of seeds) {
      if(isTalkPage(s)) continue;
      const node = nodes.find(n => n.id === s);
      if(node) { node.color = seedColorMap[s] || '#04B819'; node.val = 36; }
    }

    // BFS multi-source coloring
    const neighborMap = {};
    links.forEach(l => {
      if(!neighborMap[l.source]) neighborMap[l.source] = [];
      neighborMap[l.source].push(l.target);
      if(!neighborMap[l.target]) neighborMap[l.target] = [];
      neighborMap[l.target].push(l.source);
    });
    const distances = {}, owner = {};
    const q = [];
    for(const s of seeds) if(!isTalkPage(s) && articleSet.has(s)) { distances[s]=0; owner[s]=s; q.push(s); }
    while(q.length > 0) {
      const cur = q.shift();
      const d = distances[cur];
      const ngh = neighborMap[cur] || [];
      for(const nb of ngh) {
        if(distances[nb] === undefined) { distances[nb] = d+1; owner[nb] = owner[cur]; q.push(nb); }
      }
    }

    function parseColorToRGB(c) {
      if(!c) return null; c=c.trim();
      if(c.startsWith('#')) {
        const hex = c.slice(1); if(hex.length===3) return hex.split('').map(h=>parseInt(h+h,16));
        return [parseInt(hex.slice(0,2),16), parseInt(hex.slice(2,4),16), parseInt(hex.slice(4,6),16)];
      } else if(c.startsWith('rgb')) { const m = c.match(/\d+/g); if(m && m.length>=3) return m.slice(0,3).map(x=>parseInt(x,10)); }
      return null;
    }
    function rgbToString(rgb) { return `rgb(${rgb[0]},${rgb[1]},${rgb[2]})`; }
    function lightenColor(hexOrRgb, percent) { const rgb = parseColorToRGB(hexOrRgb); if(!rgb) return hexOrRgb; let [r,g,b]=rgb; r=Math.min(255,Math.max(0,Math.round(r+percent))); g=Math.min(255,Math.max(0,Math.round(g+percent))); b=Math.min(255,Math.max(0,Math.round(b+percent))); return rgbToString([r,g,b]); }

    for(const n of nodes) {
      if(seedColorMap[n.id]) continue;
      const d = distances[n.id];
      if(d === undefined) { n.color = '#dddddd'; continue; }
      if(d === 0) continue;
      const nearest = owner[n.id] || null;
      const base = nearest ? seedColorMap[nearest] : '#04B819';
      n.color = lightenColor(base, d * 18);
    }

    // set link color blends
    for(const l of links) {
      const sNode = nodes.find(n=>n.id===l.source), tNode = nodes.find(n=>n.id===l.target);
      if(sNode && tNode) {
        const r1 = parseColorToRGB(sNode.color)||[255,255,255], r2 = parseColorToRGB(tNode.color)||[255,255,255];
        l.color = rgbToString([Math.round((r1[0]+r2[0])/2), Math.round((r1[1]+r2[1])/2), Math.round((r1[2]+r2[2])/2)]);
      } else l.color = '#cccccc';
    }

    rawData = { nodes, links };
    window.rawData = rawData;
    Graph.graphData(rawData);
    initLinkStatesFromRaw();
    Graph.refresh();
    document.getElementById('hud-status').innerText = `Fetched ${nodes.length} nodes, ${links.length} links.`;
  } catch(e) {
    console.error('regen error', e);
    document.getElementById('hud-status').innerText = 'Error regenerating graph (see console)';
  }
});

/* Hover display: name + summary */
Graph.onNodeHover(node => {
  if(node) document.getElementById('portal-display').innerText = `${node.name}\n\n${node.summary || ''}`;
  else document.getElementById('portal-display').innerText = '';
});

/* Initialize link states for any preloaded data */
initLinkStatesFromRaw();

</script>
</body>
</html>
